{"ID":"20140114224616","Title":"Allocation with make","Markdown":"Back to allocation. The built-in function make(T, args) serves a purpose different from new(T). It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is nil. For slices, maps, and channels, make initializes the internal data structure and prepares the value for use. For instance,\r\n\r\nmake([]int, 10, 100)\r\nallocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. (When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast, new([]int) returns a pointer to a newly allocated, zeroed slice structure, that is, a pointer to a nil slice value.\r\n\r\nThese examples illustrate the difference between new and make.\r\n\u003cpre\u003e\r\nvar p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful\r\nvar v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints\r\n\r\n// Unnecessarily complex:\r\nvar p *[]int = new([]int)\r\n*p = make([]int, 100, 100)\r\n\r\n// Idiomatic:\r\nv := make([]int, 100)\r\n\u003c/pre\u003e\r\nRemember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly.","Body":"\u003cp\u003eBack to allocation. The built-in function make(T, args) serves a purpose different from new(T). It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is nil. For slices, maps, and channels, make initializes the internal data structure and prepares the value for use. For instance,\u003c/p\u003e\n\n\u003cp\u003emake([]int, 10, 100)\nallocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. (When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast, new([]int) returns a pointer to a newly allocated, zeroed slice structure, that is, a pointer to a nil slice value.\u003c/p\u003e\n\n\u003cp\u003eThese examples illustrate the difference between new and make.\n\u003cpre\u003e\nvar p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful\nvar v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints\u003c/p\u003e\n\n\u003cp\u003e// Unnecessarily complex:\nvar p *[]int = new([]int)\n*p = make([]int, 100, 100)\u003c/p\u003e\n\n\u003cp\u003e// Idiomatic:\nv := make([]int, 100)\n\u003c/pre\u003e\nRemember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly.\u003c/p\u003e\n"}